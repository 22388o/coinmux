# public insert_key and request_key
CoinJoinList:
{
  Version: 1
  Identifier: 12345 # Random value used for InputList#Signature
  MessagePublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other MessagePublicKey
  Amount: 2000000 # in satoshi, n^2
  MinimumSize: 5 # number of inputs / outputs
  InputList: { InsertKey: "InsertKey", RequestKey: "RequestKey" }
  #InputAliveList: { InsertKey: "InsertKey", RequestKey: "RequestKey" }
  MessageVerificationFixed: { RequestKey: "RequestKey" }
  OutputList: { InsertKey: "InsertKey", RequestKey: "RequestKey" }
  TransactionFixed: { RequestKey: "RequestKey" }
  StatusVariable: { RequestKey: "RequestKey" }
}

# Updated with status information
StatusVariable:
{
  Identifier: 12345 # Random value used for InputAliveList#EncryptedStatusIdentifier
  Status: "WaitingForInputs" | "WaitingForOutputs" | "WaitingForSignatures" | "WaitingForConfirmation" | "Failed" | "Complete"
  TransactionId: null | "123...abc" # transaction indicates complete and should be published to block chain
  UpdatedAt: {
    BlockHeight: 270794
    Nonce: 2617132268
  }
}

# Public insert_key and request_key
# Every client posts all of their input individually
InputList:
{
  MessagePublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other MessagePublicKey; ensure uniqueness
  Address: "1abc..." # ensure uniqueness
  PublicKey: "123...abc" # ensure uniqueness
  ChangeAddress: "1abc" # Null if no change
  ChangeAmount: 1234 # Satoshi (Transaction fee = Coins@InputList#Address - CoinJoinList#Amount - InputList#ChangeAmount)
  Signature: "123...abc" # Signature with (PrivateKey, CoinJoinList#Identifier) to show ownership of address
}

# Public insert_key and request_key
# Participants insert message to indicate they are alive
#InputAliveList:
#{
#  Address: "1abc..."
#  EncryptedStatusIdentifier: "123...abc"
#}


# Created after input list has enough inputs for mixing (inputs should be validated that they have enough BTC available)
# Only accepted inputs are given message verification
# Identifier is only encrypted once and shared to ensure that Controller cannot link inputs to outputs by giving each input a different identifier
MessageVerificationFixed:
{
  EncryptedMessageIdentifier: '123...abc' # a pseudo-random value encrypted with AES-256-CBC and a secret key
  EncryptedSecretKeys: {
    '#MessagePublicKey': '123...abc', # secret key for #EncryptedMessageIdentifier encrypted PKI for each InputList#MessagePublicKey that will be in transaction
    ...
  }
}

# Public insert_key and request_key
# Every client posts all of their outputs individually
OutputList:
{
  Address: "1abc..."
  # This scheme maintains no link between the InputList and the OutputList and ensures that we only add outputs owned by an input.
  # 1. Decrypt my MessageVerificationFixed#EncryptedIdentifierPrivateKeys to get private key for MessageVerificationFixed#EncryptedIdentifier
  # 2. Decrypt MessageVerificationFixed#EncryptedIdentifier with private key to get Identifier to allow signing
  # 3. Hash (Identifier + Address) with OutputList#MessagePublicKey to CoinJoinList#MessagePublicKey
  MessageVerification: '123...abc'
}

# Readable by anyone, writeable only by controller
# Controller publishes only once a transaction that meets its criteria (number of outputs)
# Participant only follows TransactionSignatureList when all rules followed and correctly contains all of his inputs and outputs
TransactionFixed:
{
  TransactionSignatureList: { InsertKey: "InsertKey", RequestKey: "RequestKey" }
  # RedeemScript: "5234" # created from all input public keys, only necessary if multisig
  # script should probably just be default and not present
  Inputs: [
    {
      PublicKey: "123...abc"
      TransactionId: "123...abc"
      InputIndex: 0
      Amount: 1234
      Signature: "123...abc"
    },
    {
      PublicKey: "789...xyz"
      TransactionId: "789...xyz"
      InputIndex: 0
      Amount: 2345
      Signature: "789...xyz"
    }
  ]
  Outputs: [
    {
      Address: "1abc..." # coin join addresses
      Amount: 200000000
    },
    {
      Address: "1xyz..." # change addresses
      Amount: 2345
    },
    ...
  ]
}

# Public insert_key and request_key
# Signatures occur in order of inputs.
# For each of my inputs, create full transaction, sign input, and publish here
# Controller creates transaction, polls for valid signatures, then sends transaction once received and validated, updating ControlStatusVariable
TransactionSignatureList:
{
  InputIndex: 0
  ScriptSig: '3046... 04e3...' # this is unique for every transaction
  MessagePublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other MessagePublicKey
  # 3. Signature (Identifier + InputIndex + ScriptSig) with TransactionSignatureList#MessagePublicKey to CoinJoinList#MessagePublicKey
  MessageVerification: '123...abc'
}
