# public insert_key and request_key
CoinJoins:
{
  Version: 1
  Identifier: 12345 # Random value used for Inputs#Verification
  MessagePublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other MessagePublicKey
  Participants: 5 # number of inputs / outputs
  Amount: 200000000 # in satoshi, n^2
  ParticipantTransactionFee: 10000 # each participant must pay this fee (for now 0.0005 / num participants)
  Inputs: { InsertKey: "InsertKey", RequestKey: "RequestKey" }
  MessageVerification: { InsertKey: null, RequestKey: "RequestKey" }
  Outputs: { InsertKey: "InsertKey", RequestKey: "RequestKey" }
  Transaction: { InsertKey: null, RequestKey: "RequestKey" }
  TransactionSignatures: { InsertKey: "InsertKey", RequestKey: "RequestKey" }
  Status: { InsertKey: null, RequestKey: "RequestKey" }
}

# Updated with status information
# Updatable
Status:
{
  Status: "WaitingForInputs" | "WaitingForOutputs" | "WaitingForSignatures" | "WaitingForConfirmation" | "Failed" | "Complete"
  TransactionId: null | "123...abc" # transaction indicates complete and should be published to block chain
  UpdatedAt: {
    BlockHeight: 270794
    Nonce: 2617132268
  }
}

# Public insert_key and request_key
# Every client posts all of their input individually
Inputs:
{
  MessagePublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other MessagePublicKey; ensure uniqueness
  Address: "1abc..." # ensure uniqueness
  ChangeAddress: "1abc" # Null if no change
  Verification: "123...abc" # Signature with (PrivateKey, CoinJoins#Identifier) to show ownership of address
}

# Created after input list has enough inputs for mixing (inputs should be validated that they have enough BTC available)
# Only accepted inputs are given message verification
# MessageIdentifier is encrypted by a shared key to ensure that Director cannot link inputs to outputs by giving each input a different identifier. This shared key is encrypted uniquely for each Input using its Inputs#MessagePublicKey
# Write-Once
MessageVerification:
{
  EncryptedMessageIdentifier: '123...abc' # a pseudo-random value encrypted with AES-256-CBC and a secret key
  EncryptedSecretKeys: {
    'Inputs#Addess': '123...abc', # secret key for #EncryptedMessageIdentifier encrypted PKI for each Inputs#MessagePublicKey that will be in transaction
    ...
  }
}

# Public insert_key and request_key
# Every client posts all of their outputs individually
# This scheme maintains no link between the Inputs and the Outputs and ensures that we only add outputs owned by an input.
#
# MessageVerification is created by the following:
# 1. Decrypt my MessageVerification#EncryptedSecretKeys for my Inputs#Address using private key of Inputs#MessagePublicKey to get secret key for MessageVerification#EncryptedMessageIdentifier.
# 2. Decrypt MessageVerification#EncryptedMessageIdentifier with secret key to get MessageVerification#MessageIdentifier used for Outputs#MessageVerification.
# 3. Ouputs#MessageVerifcation is the SHA256 Hash of ("${MessageVerification#MessageIdentifier}:output:${Outputs#Address}") to show knowledge of MessageVerification#MessageIdentifier.
#
# Note: it is possible for a participant to create multiple Outputs with different addresses and the Outputs will have a valid MessageVerification since all Participants share the same MessageIdentifier. This will cause the Director to create a transaction that not all Participants will sign since the Participant will not see his output address in the proposed transaction.
Outputs:
{
  Address: "1abc..."
  MessageVerification: '123...abc'
}

# Readable by anyone, writeable only by director
# Director publishes only once a transaction that meets its criteria (number of outputs)
# Participant only follows TransactionSignatures when all rules followed and correctly contains all of his inputs and outputs
# Write-Once
Transaction:
{
  # RedeemScript: "5234" # created from all input public keys, only necessary if multisig
  # script should probably just be default and not present
  TransactionHash: '1b5...bf5'
  Inputs: [
    {
      # PublicKey: "123...abc"
      TransactionId: "123...abc"
      # OutputIndex: 0
      Amount: 1234
      # Verification: "123...abc"
    },
    {
      # PublicKey: "789...xyz"
      TransactionId: "789...xyz"
      # OutputIndex: 0
      Amount: 2345
      # Verification: "789...xyz"
    }
  ]
  Outputs: [
    {
      Address: "1abc..." # coin join addresses
      Amount: 200000000
    },
    {
      Address: "1xyz..." # change addresses
      Amount: 2345
    },
    ...
  ]
}

# Public insert_key and request_key
# Signatures occur in order of inputs.
# For each of my inputs, create full transaction, sign input, and publish here
# Director creates transaction, polls for valid signatures, then sends transaction once received and validated, updating Status
TransactionSignatures:
{
  TransactionInputIndex: 0
  ScriptSig: '3046... 04e3...' # this is unique for every transaction
  MessagePublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other MessagePublicKey
  # 3. Signature (Identifier + InputIndex + ScriptSig) with TransactionSignatures#MessagePublicKey to CoinJoins#MessagePublicKey
  MessageVerification: '123...abc'
}
