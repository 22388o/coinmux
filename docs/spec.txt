# public insert_key and request_key
coin_joins:
{
  version: 1
  identifier: 12345 # Random value used for inputs#verification
  message_public_key: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other message_public_key
  participants: 5 # number of inputs / outputs
  amount: 200000000 # in satoshi, n^2
  participant_transaction_fee: 10000 # each participant must pay this fee (for now 0.0005 / num participants)
  inputs: "insert_and_request_key"
  message_verification: "request_key"
  outputs: "insert_and_request_key"
  transaction: "request_key"
  transaction_signatures: "insert_and_request_key"
  status: "request_key"
}

# Updated with status information
# Updatable
status:
{
  status: "initializing" | "waiting_for_inputs" | "waiting_for_outputs" | "waiting_for_signatures" | "waiting_for_confirmation" | "failed" | "completed"
  transaction_id: null | "123...abc" # transaction id available during while waiting for confirmations or completed
  updated_at: {
    block_height: 270794
    nonce: 2617132268
  }
}

# Public insert_key and request_key
# Every client posts all of their input individually
inputs:
{
  message_public_key: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other message_public_key; ensure uniqueness
  address: "1abc..." # ensure uniqueness
  change_address: "1abc" # Null if no change
  change_transaction_output_identifier: 67890 # A unique identifier to ensure my change output exists in the transaction
  verification: "123...abc" # Signature with (private_key, coin_joins#identifier) to show ownership of address
}

# Created after input list has enough inputs for mixing (inputs should be validated that they have enough BTC available)
# Only accepted inputs are given message verification
# message_identifier is encrypted by a shared key to ensure that Director cannot link inputs to outputs by giving each input a different identifier. This shared key is encrypted uniquely for each input using its inputs#message_public_key
# Write-Once
message_verification:
{
  encrypted_message_identifier: '123...abc' # a pseudo-random value encrypted with AES-256-CBC and a secret key
  encrypted_secret_keys: {
    'inputs#addess': '123...abc', # secret key for #encrypted_message_identifier encrypted PKI for each inputs#message_public_key that will be in transaction
    ...
  }
}

# Public insert_key and request_key
# Every client posts all of their outputs individually
# This scheme maintains no link between the inputs and the outputs and ensures that we only add outputs owned by an input.
#
# message_verification is created by the following:
# 1. Decrypt my message_verification#encrypted_secret_keys for my inputs#address using private key of inputs#message_public_key to get secret key for message_verification#encrypted_message_identifier.
# 2. Decrypt message_verification#encrypted_message_identifier with secret key to get message_verification#message_identifier used for outputs#message_verification.
# 3. outputs#message_verifcation is the SHA256 Hash of ("output:${message_verification#message_identifier}:${outputs#address}") to show knowledge of message_verification#message_identifier.
#
# Note: it is possible for a participant to create multiple Outputs with different addresses and the outputs will have a valid message_verification since all Participants share the same message_identifier. This will cause the Director to create a transaction that not all Participants will sign since the Participant will not see his output address in the proposed transaction.
outputs:
{
  address: "1abc..."
  message_verification: '123...abc'
  transaction_output_identifier: 12345 # A unique identifier to ensure my output exists in the transaction when multiple outputs going to the same address (https://bitcointalk.org/index.php?topic=279249.msg4577566#msg4577566)
}

# Readable by anyone, writeable only by Director
# Director publishes only once a transaction that meets its criteria (correct number of inputs and verified outputs)
# Participant only creates transaction_signatures when has correct number of inputs/outputs and correctly contains all of his inputs and outputs
# Write-Once
transaction:
{
  inputs: [
    {
      transaction_id: "123...abc"
      output_index: 0
    },
    {
      transaction_id: "789...xyz"
      output_index: 0
    },
    ...
  ]
  outputs: [
    {
      address: "1abc..." # coin join addresses
      amount: 200000000
      identifier: 12345
    },
    {
      address: "1xyz..." # change addresses
      amount: 2345
      identifier: 67890
    },
    ...
  ]
}

# Public insert_key and request_key
# Signatures occur in order of inputs.
# For each of my inputs, create full transaction, sign input, and publish here
# Director creates transaction, polls for valid signatures, then sends transaction once received and validated, updating status
# transaction_signatures#message_verifcation is the SHA256 Hash of ("transaction_signature:${message_verification#message_identifier}:${transaction_signatures#transaction_input_index}:${transaction_signatures#script_sig}") to show knowledge of message_verification#message_identifier.
transaction_signatures:
{
  transaction_input_index: 0
  script_sig: '304604e3...==' # Base64 encoded
  message_verification: '123...abc'
}
