# public insert_key and request_key
CoinJoins:
{
  Version: 1
  Identifier: 12345 # Random value used for Inputs#Verification
  MessagePublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other MessagePublicKey
  Participants: 5 # number of inputs / outputs
  Amount: 200000000 # in satoshi, n^2
  ParticipantTransactionFee: 10000 # each participant must pay this fee (for now 0.0005 / num participants)
  Inputs: "insert_and_request_key"
  MessageVerification: "request_key"
  Outputs: "insert_and_request_key"
  Transaction: "request_key"
  TransactionSignatures: "insert_and_request_key"
  Status: "request_key"
}

# Updated with status information
# Updatable
Status:
{
  Status: "WaitingForInputs" | "WaitingForOutputs" | "WaitingForSignatures" | "WaitingForConfirmation" | "Failed" | "Complete"
  TransactionId: null | "123...abc" # transaction indicates complete and should be published to block chain
  UpdatedAt: {
    BlockHeight: 270794
    Nonce: 2617132268
  }
}

# Public insert_key and request_key
# Every client posts all of their input individually
Inputs:
{
  MessagePublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other MessagePublicKey; ensure uniqueness
  Address: "1abc..." # ensure uniqueness
  ChangeAddress: "1abc" # Null if no change
  Verification: "123...abc" # Signature with (PrivateKey, CoinJoins#Identifier) to show ownership of address
}

# Created after input list has enough inputs for mixing (inputs should be validated that they have enough BTC available)
# Only accepted inputs are given message verification
# MessageIdentifier is encrypted by a shared key to ensure that Director cannot link inputs to outputs by giving each input a different identifier. This shared key is encrypted uniquely for each Input using its Inputs#MessagePublicKey
# Write-Once
MessageVerification:
{
  EncryptedMessageIdentifier: '123...abc' # a pseudo-random value encrypted with AES-256-CBC and a secret key
  EncryptedSecretKeys: {
    'Inputs#Addess': '123...abc', # secret key for #EncryptedMessageIdentifier encrypted PKI for each Inputs#MessagePublicKey that will be in transaction
    ...
  }
}

# Public insert_key and request_key
# Every client posts all of their outputs individually
# This scheme maintains no link between the Inputs and the Outputs and ensures that we only add outputs owned by an input.
#
# MessageVerification is created by the following:
# 1. Decrypt my MessageVerification#EncryptedSecretKeys for my Inputs#Address using private key of Inputs#MessagePublicKey to get secret key for MessageVerification#EncryptedMessageIdentifier.
# 2. Decrypt MessageVerification#EncryptedMessageIdentifier with secret key to get MessageVerification#MessageIdentifier used for Outputs#MessageVerification.
# 3. Ouputs#MessageVerifcation is the SHA256 Hash of ("output:${MessageVerification#MessageIdentifier}:${Outputs#Address}") to show knowledge of MessageVerification#MessageIdentifier.
#
# Note: it is possible for a participant to create multiple Outputs with different addresses and the Outputs will have a valid MessageVerification since all Participants share the same MessageIdentifier. This will cause the Director to create a transaction that not all Participants will sign since the Participant will not see his output address in the proposed transaction.
Outputs:
{
  Address: "1abc..."
  MessageVerification: '123...abc'
}

# Readable by anyone, writeable only by Director
# Director publishes only once a transaction that meets its criteria (correct number of inputs and verified outputs)
# Participant only creates TransactionSignatures when has correct number of inputs/outputs and correctly contains all of his inputs and outputs
# Write-Once
Transaction:
{
  Inputs: [
    {
      TransactionId: "123...abc"
      OutputIndex: 0
    },
    {
      TransactionId: "789...xyz"
      OutputIndex: 0
    },
    ...
  ]
  Outputs: [
    {
      Address: "1abc..." # coin join addresses
      Amount: 200000000
    },
    {
      Address: "1xyz..." # change addresses
      Amount: 2345
    },
    ...
  ]
}

# Public insert_key and request_key
# Signatures occur in order of inputs.
# For each of my inputs, create full transaction, sign input, and publish here
# Director creates transaction, polls for valid signatures, then sends transaction once received and validated, updating Status
# TransactionSignatures#MessageVerifcation is the SHA256 Hash of ("transaction_signature:${MessageVerification#MessageIdentifier}:${TransactionSignatures#TransactionInputIndex}:${TransactionSignatures#ScriptSig}") to show knowledge of MessageVerification#MessageIdentifier.
TransactionSignatures:
{
  TransactionInputIndex: 0
  ScriptSig: '304604e3...==' # Base64 encoded
  MessageVerification: '123...abc'
}
