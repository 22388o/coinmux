# public insert_key and request_key
# Should i have one list per Amount? Probably yes for speed purposes!
CoinJoinList
{
  Version: 1
  ControllerInstance: { RequestKey: "RequestKey" }
}

# Readable by anyone, writeable only by controller
ControllerInstance
{
  MessagePublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other MessagePublicKey
  Amount: 2000000 # in satoshi, n^2
  MinimumSize: 5 # number of inputs / outputs
  InputList: { InsertKey: "InsertKey", RequestKey: "RequestKey" }
  MessageVerificationInstance: { RequestKey: "RequestKey" }
  OutputList: { InsertKey: "InsertKey", RequestKey: "RequestKey" }
  TransactionInstance: { RequestKey: "RequestKey" }
  ControlStatusQueue: { RequestKey: "RequestKey" }
}

# Updated with status information
ControlStatusQueue
{
  Status: "WaitingForInputs" | "WaitingForOutputs" | "WaitingForSignatures" | "WaitingForConfirmation" | "Failed" | "Complete"
  TransactionId: null | "123...abc" # transaction indicates complete and should be published to block chain
  UpdatedAt: {
    BlockHeight: 270794
    Nonce: 2617132268
  }
}

# Public insert_key and request_key
# Every client posts all of their input individually
InputList:
{
  MessagePublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other MessagePublicKey
  Address: "1abc..."
  PublicKey: "123...abc"
  ChangeAddress: "1abc" # Null if no change
  ChangeAmount: 1234 # Satoshi (Transaction fee = Coins@InputList#Address - ControllerInstance#Amount - InputList#ChangeAmount)
  Signature: "123...abc" # Signature with (PrivateKey, ControllerInstance#RequestKey) to show ownership of address
  
  # Adding proof of work is possibly worse... it can cause the controller to get CPU jammed, so don't do it
  # Nonce: 123...789 # must be unique for this InputList#Address)
  # ProofOfWork: "123...abc" # Bcrypt hash of (Address, ControllerInstance#RequestKey, Nonce)
}

# Created after input list has enough inputs for mixing (inputs should be validated that they have enough BTC available)
# Only accepted inputs are given message verification
MessageVerificationInstance:
{
  IdentifierPublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); public key used below; unique from all others
  EncryptedIdentifier: '123...abc' # a random value encrypted with private key for #IdentifierPublicKey; input with access to the Identifier is verified, but we purposefully cannot identify which input sends a verified message
  EncryptedIdentifierPrivateKeys: [
    '123...abc', # private key for MessageVerificationInstance#IdentifierPublicKey encrypted with each InputList#MessagePublicKey that will be in transaction
    ...
  ]
}

# Public insert_key and request_key
# Every client posts all of their outputs individually
OutputList:
{
  Address: "1abc..."
  MessagePublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other MessagePublicKey
  # This scheme maintains no link between the InputList and the OutputList and ensures that we only add outputs owned by an input.
  # 1. Decrypt my MessageVerificationInstance#EncryptedIdentifierPrivateKeys to get private key for MessageVerificationInstance#EncryptedIdentifier
  # 2. Decrypt MessageVerificationInstance#EncryptedIdentifier with private key to get Identifier to allow communication
  # 3. Encrypt (Identifier + Address) with OutputList#MessagePublicKey to ControllerInstance#MessagePublicKey
  EncryptedMessageValidation: '123...abc'
}

# Readable by anyone, writeable only by controller
# Controller publishes only once a transaction that meets its criteria (number of outputs)
# Participant only follows TransactionSignatureList when all rules followed and correctly contains all of his inputs and outputs
TransactionInstance:
{
  TransactionSignatureList: { InsertKey: "InsertKey", RequestKey: "RequestKey" }
  # RedeemScript: "5234" # created from all input public keys, only necessary if multisig
  # script should probably just be default and not present
  Inputs: [
    {
      PublicKey: "123...abc"
      TransactionId: "123...abc"
      InputIndex: 0
      Amount: 1234
      Signature: "123...abc"
    },
    {
      PublicKey: "789...xyz"
      TransactionId: "789...xyz"
      InputIndex: 0
      Amount: 2345
      Signature: "789...xyz"
    }
  ]
  Outputs: [
    {
      Address: "1abc..." # coin join addresses
      Amount: 200000000
    },
    {
      Address: "1xyz..." # change addresses
      Amount: 2345
    },
    ...
  ]
}

# Public insert_key and request_key
# Signatures occur in order of inputs.
# For each of my inputs, create full transaction, sign input, and publish here
# Controller creates transaction, polls for valid signatures, then sends transaction once received and validated, updating ControlStatusQueue
TransactionSignatureList:
{
  InputIndex: 0
  ScriptSig: '3046... 04e3...' # this is unique for every transaction
  MessagePublicKey: '123...abc' # RSA 2048 PKI (PKCS1_PADDING); unique from other MessagePublicKey
  # 3. Encrypt (Identifier + InputIndex + ScriptSig) with TransactionSignatureList#MessagePublicKey to ControllerInstance#MessagePublicKey
  EncryptedMessageValidation: '123...abc'
}
